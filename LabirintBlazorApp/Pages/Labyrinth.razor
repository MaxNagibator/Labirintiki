@page "/labirint"

<PageTitle>Лабиринт</PageTitle>

<h1>Лабиринт</h1>

<div class="key-interceptor" @onkeydown="OnKeyDown" @ref="_keyInterceptorRef" tabindex="0">
    @if (_isInit == false)
    {
        <p>
            <em>Загрузка...</em>
        </p>
    }
    else
    {
        <div class="field">
            @{
                var boxSize = 370 / _originalSizeDisplay;
                var wallWidth = Math.Max(1, boxSize / 10 * 2);
                var shift = boxSize - wallWidth * 2;

                for (int i = 1; i < _labSize - 1; i += 2)
                {
                    for (int j = 1; j < _labSize - 1; j += 2)
                    {
                        if (lab[i, j - 1] == 0)
                        {
                            <DrawLine Width="@(wallWidth)"
                                      X1="@(j * boxSize - boxSize)"
                                      X2="@(j * boxSize - boxSize)"
                                      Y1="@(i * boxSize - boxSize)"
                                      Y2="@(i * boxSize + boxSize)" />
                        } //leftborder

                        if (lab[i - 1, j] == 0)
                        {
                            <DrawLine Width="@(wallWidth)"
                                      X1="@(j * boxSize - boxSize)"
                                      X2="@(j * boxSize + boxSize)"
                                      Y1="@(i * boxSize - boxSize)"
                                      Y2="@(i * boxSize - boxSize)" />
                        } //upborder

                        if (i == _labSize - 2 || j == _labSize - 2)
                        {
                            if (lab[i, j + 1] == 0)
                            {
                                <DrawLine Width="@(wallWidth)"
                                          X1="@(j * boxSize + boxSize)"
                                          X2="@(j * boxSize + boxSize)"
                                          Y1="@(i * boxSize - boxSize)"
                                          Y2="@(i * boxSize + boxSize)" />
                            } //rightborder

                            if (lab[i + 1, j] == 0)
                            {
                                <DrawLine Width="@(wallWidth)"
                                          X1="@(j * boxSize - boxSize)"
                                          X2="@(j * boxSize + boxSize)"
                                          Y1="@(i * boxSize + boxSize)"
                                          Y2="@(i * boxSize + boxSize)" />
                            } //downborder
                        }


                        if (_sand[i, j] == 0)
                        {
                            var top = (i) * boxSize - wallWidth;
                            var left = (j - 1) * boxSize + shift - wallWidth;
                            <div style="position:absolute;
                                                        left: @(left)px;
                                                        top: @(top)px;
                                                        width: @(boxSize)px;
                                                        height: @(boxSize)px;">
                                <img src="/images/sand.png" style="width: @(boxSize)px; height: @(boxSize)px;" />
                            </div>
                        }
                    }
                }

                var myTop = (_myPositionX - 1) * boxSize + (shift * 2 / 3 + wallWidth);
                var myLeft = (_myPositionY - 1) * boxSize + (shift / 2 + wallWidth);
                <div style="position:absolute;
                                                left: @(myTop)px;
                                                top: @(myLeft)px;
                                            width: @(boxSize)px;
                                            height: @(boxSize)px;">
                    <img src="/images/runner.png" style="width: @(boxSize)px; height: @(boxSize)px;" />
                </div>
            }
        </div>

        <div style="position: absolute; right: 20px; width: 250px;">
            <label>size:</label>
            <input type="text" @bind="@_originalSize" @oninput="@(ui => {
                var size = int.Parse(ui.Value.ToString());
                if(size < 1){ size = 1;}
                if(size > 100){size = 100; }
                    _originalSize = size;
                    StateHasChanged();
                })" />
            <div>
                <input type="range" id="volume" name="volume"
                    @onchange="@(ui => {_originalSize = int.Parse(ui.Value.ToString());})" 
                min="1" max="100" />
                <label for="volume">Volume</label>
            </div>
            <label>@_score</label>
            <button @onclick="Generate">generate</button>
        </div>
    }

</div>

@code {
    const string MoveUpKey = "ArrowUp";
    const string MoveDownKey = "ArrowDown";
    const string MoveLeftKey = "ArrowLeft";
    const string MoveRightKey = "ArrowRight";

    private int _myPositionX;
    private int _myPositionY;

    private ElementReference _keyInterceptorRef;
    private bool _isInit;

    private int _originalSize;
    private int _originalSizeDisplay;
    private int _labSize;

    private int[,] lab;
    private int[,] lab2;
    private int[,] _sand;
    private bool _exitNotFound;
    private int _exitBoxPostionX;
    private int _exitBoxPostionY;
    private int _score = 0;

    protected override Task OnInitializedAsync()
    {
        _originalSize = 16;
        Generate();
        return Task.CompletedTask;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await _keyInterceptorRef.FocusAsync();
        }
    }

    private void OnKeyDown(KeyboardEventArgs e)
    {
        if (_exitNotFound)
        {
            // if (e.KeyCode == Keys.A && Global.molot > 0)
            // {
            //     Global.ataka = true;
            //     Global.molot--;
            //     textmolot.Text = Convert.ToString(Global.molot);
            // }
            // Graphics g = this.CreateGraphics();
            // Pen p = new Pen(BackColor, Global.step / 5);
            // if (e.KeyCode == Keys.B && Global.bomba > 0)
            // {
            //     if (_myPositionX != Global.size * 2 - 1)
            //     {
            //         Global.lab[_myPositionX + 1, _myPositionY] = 1;
            //     }
            //     if (_myPositionX != 1)
            //     {
            //         Global.lab[_myPositionX - 1, _myPositionY] = 1;
            //     }
            //     if (_myPositionY != 1)
            //     {
            //         Global.lab[_myPositionX, _myPositionY - 1] = 1;
            //     }
            //     if (_myPositionY != Global.size * 2 - 1)
            //     {
            //         Global.lab[_myPositionX, _myPositionY + 1] = 1;
            //     }
            //     clear();
            //     Global.bomba--;
            //     textbomb.Text = Convert.ToString(Global.bomba);
            //     Global.ataka = false;
            // }
            // if (Global.ataka && e.KeyCode != Keys.A)
            // {
            //     if (e.KeyCode == Keys.Down && _myPositionX != Global.size * 2 - 1)
            //     {
            //         Global.lab[_myPositionX + 1, _myPositionY] = 1;
            //     }
            //     if (e.KeyCode == Keys.Up && _myPositionX != 1)
            //     {
            //         Global.lab[_myPositionX - 1, _myPositionY] = 1;
            //     }
            //     if (e.KeyCode == Keys.Left && _myPositionY != 1)
            //     {
            //         Global.lab[_myPositionX, _myPositionY - 1] = 1;
            //     }
            //     if (e.KeyCode == Keys.Right && _myPositionY != Global.size * 2 - 1)
            //     {
            //         Global.lab[_myPositionX, _myPositionY + 1] = 1;
            //     }
            //     clear();
            //     Global.ataka = false;
            // }
            if (true) //!Global.ataka)
            {
                switch (e.Key)
                {
                    case MoveUpKey:
                        Move(0, -1);
                        break;

                    case MoveDownKey:
                        Move(0, 1);
                        break;

                    case MoveLeftKey:
                        Move(-1, 0);
                        break;

                    case MoveRightKey:
                        Move(1, 0);
                        break;
                }
            }
        }
    }

    private void Move(int xOffset, int yOffset)
    {
        if (lab[_myPositionY + yOffset, _myPositionX + xOffset] == 0)
            return;

        _myPositionX += xOffset * 2;
        _myPositionY += yOffset * 2;

        if (_myPositionX == _exitBoxPostionX && _myPositionY == _exitBoxPostionY)
        {
            _exitNotFound = false;
        }
        else
        {
            if (_sand[_myPositionY, _myPositionX] == 0)
            {
                _sand[_myPositionY, _myPositionX] = 1;
                _score += 100;
            }
        }
    }

    private void Generate()
    {
        var rnd = new Random();

        _myPositionX = 1;
        _myPositionY = 1;
        _exitNotFound = true;
        if (_originalSize < 1)
        {
            _originalSize = 1;
        }
        else if (_originalSize > 100)
        {
            _originalSize = 100;
        }
        _originalSizeDisplay = _originalSize;

        var density = 3;

        int n = _originalSize * 2 + 1;
        lab = new int[n, n];
        _labSize = n;

        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (i == 0 || i == n - 1)
                {
                    lab[i, j] = 0;
                }

                if (j == 0 || j == n - 1)
                {
                    lab[i, j] = 0;
                }

                if (i % 2 == 1 && j % 2 == 1)
                {
                    lab[i, j] = 2;
                }

                if (i > 0 && i % 2 == 0 && i < n - 1 && j > 0 && j % 2 == 1 && j < n - 1 ||
                    i > 0 && i % 2 == 1 && i < n - 1 && j > 0 && j % 2 == 0 && j < n - 1)
                {
                    lab[i, j] = rnd.Next(0, density);
                }
            }

            _exitBoxPostionX = n / 2 - (_originalSize % 2 == 0 ? 1 : 0);
            _exitBoxPostionY = n;
            lab[_exitBoxPostionY - 1, _exitBoxPostionX] = 1;
        }

        lab2 = new int[n, n];

        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < n; j++)
            {
                lab2[i, j] = 1;
            }
        }

        _sand = lab2;

        for (int i = 1; i < _labSize; i++)
        {
            _sand[rnd.Next(1, n / 2 + 1) * 2 - 1, rnd.Next(1, n / 2 + 1) * 2 - 1] = 0;
        }

        _isInit = true;
    }

}