@page "/labirint"
@using LabirintBlazorApp.Common
@inject SoundService SoundService

<PageTitle>Лабиринт</PageTitle>
<MudStack Spacing="3">
    <MudText Typo="Typo.h4">Лабиринт!</MudText>
    <KeyInterceptor OnMoveKeyDown="OnMoveKeyDown" OnAttackKeyDown="OnAttackKeyDown" @ref="_keyInterceptor">
        @if (_isInit == false)
        {
            <MudStack AlignItems="AlignItems.Center" Row>
             <MudProgressCircular Indeterminate />
                 <MudText Typo="Typo.body1">Загрузка..</MudText>
             </MudStack>
        }
        else
        {
            <div class="field">
                @{
                    int halfBoxSize = 370 / _originalSizeDisplay;
                    int wallWidth = Math.Max(1, halfBoxSize / 10 * 2);
                    int entityBoxSize = halfBoxSize * 2 - wallWidth;

                    for (int i = 1; i < _labSize - 1; i += 2)
                    {
                        for (int j = 1; j < _labSize - 1; j += 2)
                        {
                            if (lab[i, j - 1] == 0)
                            {
                                <DrawLine Width="@(wallWidth)" Color="@Parameters.Labyrinth.Color"
                                          X1="@(j * halfBoxSize - halfBoxSize)"
                                          X2="@(j * halfBoxSize - halfBoxSize)"
                                          Y1="@(i * halfBoxSize - halfBoxSize)"
                                          Y2="@(i * halfBoxSize + halfBoxSize)" />
                            } //leftborder

                            if (lab[i - 1, j] == 0)
                            {
                                <DrawLine Width="@(wallWidth)" Color="@Parameters.Labyrinth.Color"
                                          X1="@(j * halfBoxSize - halfBoxSize)"
                                          X2="@(j * halfBoxSize + halfBoxSize)"
                                          Y1="@(i * halfBoxSize - halfBoxSize)"
                                          Y2="@(i * halfBoxSize - halfBoxSize)" />
                            } //upborder

                            if (i == _labSize - 2 || j == _labSize - 2)
                            {
                                if (lab[i, j + 1] == 0)
                                {
                                    <DrawLine Width="@(wallWidth)" Color="@Parameters.Labyrinth.Color"
                                              X1="@(j * halfBoxSize + halfBoxSize)"
                                              X2="@(j * halfBoxSize + halfBoxSize)"
                                              Y1="@(i * halfBoxSize - halfBoxSize)"
                                              Y2="@(i * halfBoxSize + halfBoxSize)" />
                                } //rightborder

                                if (lab[i + 1, j] == 0)
                                {
                                    <DrawLine Width="@(wallWidth)" Color="@Parameters.Labyrinth.Color"
                                              X1="@(j * halfBoxSize - halfBoxSize)"
                                              X2="@(j * halfBoxSize + halfBoxSize)"
                                              Y1="@(i * halfBoxSize + halfBoxSize)"
                                              Y2="@(i * halfBoxSize + halfBoxSize)" />
                                } //downborder
                            }

                            if (_sand[i, j] == 0)
                            {
                                int left = (j - 1) * halfBoxSize + wallWidth;
                                int top = (i - 1) * halfBoxSize + wallWidth;
                                <div style="position:absolute;
                                                    display: flex;
                                                    justify-content: center;
                                                    align-items: flex-end;
                                                    left: @(left)px;
                                                    top: @(top)px;
                                                    width: @(entityBoxSize)px;
                                                    height: @(entityBoxSize)px;">
                                    <img src="/images/sand.png" style="width: @(halfBoxSize)px; height: @(halfBoxSize)px;" />
                                </div>
                            }
                        }
                    }

                    int myLeft = (_myPositionXDisplay - 1) * halfBoxSize + wallWidth;
                    int myTop = (_myPositionYDisplay - 1) * halfBoxSize + wallWidth;
                    <div style="position:absolute;
                                        display: flex;
                                        justify-content: center;
                                        align-items: center;
                                        z-index: 100;
                                        left: @(myLeft)px;
                                        top: @(myTop)px;
                                        width: @(entityBoxSize)px;
                                        height: @(entityBoxSize)px;">
                        <img src="/images/runner.png" style="width: @(halfBoxSize)px; height: @(halfBoxSize)px;" />
                    </div>
                    if (!_exitNotFound)
                    {
                        int wayWidth = Math.Max(1, halfBoxSize / 10 * 2);
                        var wayLineSize = halfBoxSize;
                        int x = _myPositionX;
                        int y = _myPositionY;
                        road t = _way;
                        while (t != null)
                        {
                            if (t.cur == 1)
                            {
                                <DrawLine Color="@("darkred")" Width="@(wallWidth)" X1="@(y * wayLineSize)" Y1="@(x * wayLineSize)" X2="@((y + 2) * wayLineSize)" Y2="@(x * wayLineSize)" />
                                y += 2;
                            }
                            if (t.cur == 2)
                            {
                                <DrawLine Color="@("darkred")" Width="@(wallWidth)" X1="@(y * wayLineSize)" Y1="@(x * wayLineSize)" X2="@((y - 2) * wayLineSize)" Y2="@(x * wayLineSize)" />
                                y -= 2;
                            }
                            if (t.cur == 3)
                            {
                                <DrawLine Color="@("darkred")" Width="@(wallWidth)" X1="@(y * wayLineSize)" Y1="@(x * wayLineSize)" X2="@(y * wayLineSize)" Y2="@((x + 2) * wayLineSize)" />
                                x += 2;
                            }
                            if (t.cur == 4)
                            {
                                <DrawLine Color="@("darkred")" Width="@(wallWidth)" X1="@(y * wayLineSize)" Y1="@(x * wayLineSize)" X2="@(y * wayLineSize)" Y2="@((x - 2) * wayLineSize)" />
                                x -= 2;
                            }
                            t = t.next;
                        }
                    }
                }
            </div>

            <div style="position: absolute; right: 20px; width: 250px;">
                <MudStack Spacing="3">
                    <MudText Typo="Typo.h6">Очки: @_score</MudText>
                    <MudDivider Class="my-2" Style="height:2px" DividerType="DividerType.FullWidth" />
                    <MudText Typo="Typo.h5">Параметры:</MudText>
                    <MudStack>
                        <MudNumericField Label="Размер" Min="@MinSize" Max="@MaxSize" DebounceInterval="300" Value="@_originalSize" HelperText="Попробуй тут шифт + колесо мыши" />
                        <MudSlider @bind-Value="_originalSize" Min="@MinSize" Max="@MaxSize" Color="Color.Info" Size="Size.Medium" />
                    </MudStack>
                    <MudStack Row>
                        <MudIcon Color="Color.Warning" Icon="@MaterialDesignIcons.Normal.Hammer" Size="Size.Large" />
                        <MudText Color="Color.Warning" Typo="Typo.h6">@_molotCount/@MaxMolotCount</MudText>
                    </MudStack>
                    <MudStack Row>
                        <MudIcon Color="Color.Error" Icon="@MaterialDesignIcons.Normal.Bomb" Size="Size.Large" />
                        <MudText Color="Color.Error" Typo="Typo.h6"> @_bombaCount/@MaxBombaCount</MudText>
                    </MudStack>
                    <MudButton OnClick="GenerateAsync" Variant="Variant.Outlined" Color="Color.Info" FullWidth>Генерировать</MudButton>
                    <MudButton OnClick="FocusFieldAsync" Variant="Variant.Outlined" Color="Color.Info" FullWidth>Играть</MudButton>
                    <MudButton OnClick="FindExitAsync" Variant="Variant.Outlined" Color="Color.Info" FullWidth>Найти выход</MudButton>

                    <ControlSchemeSwitcher></ControlSchemeSwitcher>
                </MudStack>
            </div>
        }
    </KeyInterceptor>
</MudStack>

@code {
    const int MinSize = 1;
    const int MaxSize = 100;

    const int MaxMolotCount = 9;
    const int MaxBombaCount = 3;

    private int _myPositionX;
    private int _myPositionY;
    private int _myPositionXDisplay;
    private int _myPositionYDisplay;

    private KeyInterceptor _keyInterceptor;
    private bool _isInit;

    private int _originalSize;
    private int n;
    private int _originalSizeDisplay;
    private int _labSize;

    private int[,] lab;
    private int[,] lab2;
    private int[,] _sand;
    private bool _exitNotFound;
    private int _exitBoxPositionX;
    private int _exitBoxPositionY;
    private int _score;

    private bool _isAtaka;
    private int _bombaCount;
    private int _molotCount;
    private road? _way;
    private int _speed;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await FocusFieldAsync();
            _originalSize = 16;
            _speed = 3;
            await GenerateAsync();
            StateHasChanged();
        }
    }

    private async Task OnMoveKeyDown(MoveEventArgs moveEventArgs)
    {
        if (_exitNotFound == false)
            return;

        if (_isAtaka)
        {
            Attack(moveEventArgs.DeltaX, moveEventArgs.DeltaY);
            await SoundService.PlayAsync(SoundType.Molot);
            _isAtaka = false;
        }

        await Move(moveEventArgs.DeltaX, moveEventArgs.DeltaY);
        StateHasChanged();
    }

    private void Attack(int deltaX, int deltaY)
    {
        BreakWall(_myPositionX + deltaX, _myPositionY + deltaY);
    }

    private async void OnAttackKeyDown(AttackEventArgs attackEventArgs)
    {
        switch (attackEventArgs.Type)
        {
            case AttackType.Bomba when _bombaCount > 0:
                DetonateBomb();
                _bombaCount--;
                await SoundService.PlayAsync(SoundType.Bomb);
                _isAtaka = false;
                return;

            case AttackType.Molot when _molotCount > 0:
                _isAtaka = true;
                _molotCount--;
                break;
        }
    }

    private void DetonateBomb()
    {
        BreakWall(_myPositionX + 1, _myPositionY);
        BreakWall(_myPositionX - 1, _myPositionY);
        BreakWall(_myPositionX, _myPositionY - 1);
        BreakWall(_myPositionX, _myPositionY + 1);
    }

    private void BreakWall(int x, int y)
    {
        if (x > 0 && x < _originalSize * 2 && y > 0 && y < _originalSize * 2)
        {
            lab[y, x] = 1;
        }
    }

    private async Task Move(int xOffset, int yOffset)
    {
        if (lab[_myPositionY + yOffset, _myPositionX + xOffset] == 0)
            return;

        _myPositionX += xOffset * 2;
        _myPositionY += yOffset * 2;
        _myPositionXDisplay = _myPositionX;
        _myPositionYDisplay = _myPositionY;

        await SoundService.PlayAsync(SoundType.Step);

        if (_myPositionX == _exitBoxPositionX && _myPositionY == _exitBoxPositionY)
        {
            _exitNotFound = false;
            return;
        }

        if (_sand[_myPositionY, _myPositionX] != 0)
            return;

        _sand[_myPositionY, _myPositionX] = 1;
        _score += 100;

        await SoundService.PlayAsync(SoundType.Score);
    }

    private async Task GenerateAsync()
    {
        //todo Костыль чтоб цвет обновлялся, надо больше времени подумать.
        // (Не перерисовывает если стена осталась на прежнем месте)
        // Но в принципе то работает))))))
        _labSize = 0;
        StateHasChanged();
        await Task.Delay(1);

        _myPositionX = 1;
        _myPositionY = 1;
        _myPositionXDisplay = _myPositionX;
        _myPositionYDisplay = _myPositionY;
        _exitNotFound = true;
        _originalSize = ClampSize(_originalSize);
        _originalSizeDisplay = _originalSize;

        int density = 3;

        n = _originalSize * 2 + 1;
        lab = new int[n, n];
        _labSize = n;
        _molotCount = MaxMolotCount;
        _bombaCount = MaxBombaCount;
        _score = 0;

        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (i == 0 || i == n - 1)
                {
                    lab[i, j] = 0;
                }

                if (j == 0 || j == n - 1)
                {
                    lab[i, j] = 0;
                }

                if (i % 2 == 1 && j % 2 == 1)
                {
                    lab[i, j] = 2;
                }

                if ((i > 0 && i % 2 == 0 && i < n - 1 && j > 0 && j % 2 == 1 && j < n - 1) ||
                    (i > 0 && i % 2 == 1 && i < n - 1 && j > 0 && j % 2 == 0 && j < n - 1))
                {
                    lab[i, j] = Random.Shared.Next(0, density);
                }
            }

            _exitBoxPositionX = n / 2 - (_originalSize % 2 == 0 ? 1 : 0);
            _exitBoxPositionY = n;
            lab[_exitBoxPositionY - 1, _exitBoxPositionX] = 1;
        }

        lab2 = new int[n, n];

        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < n; j++)
            {
                lab2[i, j] = 1;
            }
        }

        _sand = lab2;

        for (int i = 1; i < _labSize; i++)
        {
            _sand[Random.Shared.Next(1, n / 2 + 1) * 2 - 1, Random.Shared.Next(1, n / 2 + 1) * 2 - 1] = 0;
        }

        _isInit = true;

        await FocusFieldAsync();
    }

    private async Task FocusFieldAsync()
    {
        await _keyInterceptor.FocusAsync();
    }

    private int ClampSize(int size)
    {
        switch (size)
        {
            case < MinSize:
                size = MinSize;
                break;

            case > MaxSize:
                size = MaxSize;
                break;
        }

        return size;
    }

    private async Task FindExitAsync()
    {

        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < n; j++)
            {
                lab2[i, j] = 1;
            }
        }
        int x = _myPositionY;
        int y = _myPositionX;
        int back;
        road way = new road();
        //pictureBox1.Location = new System.Drawing.Point((y - 1) * Global.step + Global.step / 2, (x - 1) * Global.step + Global.step / 2);
        _exitNotFound = true;
        while (_exitNotFound)
        {
            if ((x == n && y == n / 2) || (x == n && y == n / 2 - 1))
            {
                //textresult.Text = "exit: true";
                _exitNotFound = false;
                _way = way.head;
            }
            else
            {
                StateHasChanged();
                await Task.Delay(_speed);
                if (lab[x + 1, y] != 0 && lab2[x + 1, y] != 0) //down
                {
                    lab2[x + 1, y] = 0;
                    way.add(3); x += 2;

                    _myPositionXDisplay = y;
                    _myPositionYDisplay = x;
                    //pictureBox1.Location = new System.Drawing.Point((y - 1) * Global.step + Global.step / 2, (x - 1) * Global.step + Global.step / 2);
                }
                else
                    if (lab[x, y + 1] != 0 && lab2[x, y + 1] != 0) //right
                {
                    lab2[x, y + 1] = 0;
                    way.add(1); y += 2;

                    _myPositionXDisplay = y;
                    _myPositionYDisplay = x;
                    //pictureBox1.Location = new System.Drawing.Point((y - 1) * Global.step + Global.step / 2, (x - 1) * Global.step + Global.step / 2);
                }
                else
                        if (lab[x, y - 1] != 0 && lab2[x, y - 1] != 0) //left
                {
                    lab2[x, y - 1] = 0;
                    way.add(2); y -= 2;

                    _myPositionXDisplay = y;
                    _myPositionYDisplay = x;
                    //pictureBox1.Location = new System.Drawing.Point((y - 1) * Global.step + Global.step / 2, (x - 1) * Global.step + Global.step / 2);
                }
                else
                            if (lab[x - 1, y] != 0 && lab2[x - 1, y] != 0) //up
                {
                    lab2[x - 1, y] = 0;
                    way.add(4); x -= 2;

                    _myPositionXDisplay = y;
                    _myPositionYDisplay = x;
                    //pictureBox1.Location = new System.Drawing.Point((y - 1) * Global.step + Global.step / 2, (x - 1) * Global.step + Global.step / 2);
                }//1-r 2-l 3-d 4-u
                else
                {
                    if (way.size() != 0)
                    {
                        back = way.deq();
                        if (back == 1) { y -= 2; }
                        if (back == 2) { y += 2; }
                        if (back == 3) { x -= 2; }
                        if (back == 4) { x += 2; }
                    }
                    else
                    {
                        //textresult.Text = "exit: false";
                        _exitNotFound = false;
                        _way = null;
                    }
                }
            }
        }
    }

}